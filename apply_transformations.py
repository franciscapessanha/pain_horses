#!/usr/bin/env python3# -*- coding: utf-8 -*-"""Created on Sun May 24 20:27:17 2020@author: franciscapessanha"""# %%============================================================================#                          IMPORTS AND INITIALIZATIONS# ==============================================================================import matplotlib.pyplot as plt#from mpl_toolkits.mplot3d import Axes3Dfrom data_augmentation.ObjLoader import *import numpy as npimport osimport pickleimport cv2 as cvfrom data_augmentation.load_obj import *from random import randintfrom data_augmentation.transformations import *from pylab import *import scipy.linalg as lin#from pygem import RBFParameters, RBF, IDWParameters, IDWimport trimeshfrom data_augmentation.utils import *import numpy as npimport matplotlib.pyplot as pltfrom mpl_toolkits.mplot3d import Axes3Dimport globimport randomfrom scipy.spatial.transform import Rotation as Rotfrom data_augmentation.correct_edge_lms import  update_landmarksDATASET = os.path.join(os.getcwd(),'dataset')MODELS =  os.path.join(DATASET, '3D_annotations', 'models')LANDMARKS =  os.path.join(DATASET, '3D_annotations', 'landmarks')COLORS =  os.path.join(DATASET, '3D_annotations', 'colors')SHAPES =  os.path.join(DATASET, '3D_annotations', 'shapes')ANGLES =  os.path.join(DATASET, '3D_annotations', 'angles')HEAD_OBJ = os.path.join(MODELS,'head_TOSCA.obj')EAR_OBJ = os.path.join(MODELS,'ear.obj')PROFILE_OUTLINE = os.path.join(LANDMARKS,'profile_all_outline.txt')PROFILE_LEFT_NOSTRIL = os.path.join(LANDMARKS, 'profile_left_nostril.txt')CHEEK = os.path.join(LANDMARKS, 'left_cheek.txt')MOUTH = os.path.join(LANDMARKS, 'mouth.txt')LEFT_EYE = os.path.join(LANDMARKS, 'left_eye.txt')data = pickle.load(open(os.path.join(DATASET, 'lms_annotations.pkl'), "rb"))EX_FOLDER = os.path.join(os.getcwd(), 'examples')if not os.path.exists(EX_FOLDER):    os.mkdir(EX_FOLDER)#EAR_559_FILE = '559_ear.txt'EAR_FILE = os.path.join(DATASET, '3D_annotations', 'ears', '35_ear.txt')EARS_FILES = glob.glob(os.path.join(DATASET, '3D_annotations', 'ears', '*.txt'))PROFILE_TRAIN = glob.glob(os.path.join(DATASET, 'cross_val', 'profile', 'train', '*.jpg'))BACKGROUND = glob.glob(os.path.join(DATASET, 'flickr', '*.png'))pose_info = pickle.load(open(os.path.join(ANGLES, 'profile_roll_pitch_yaw.pickle'), 'rb'))# %%============================================================================#                                MAIN# ==============================================================================vertices, triangles = load_obj(HEAD_OBJ)verts_ears, tri_ears = load_obj(EAR_OBJ)correspondence, zeros =  symetric(vertices)profile_outline = load_lms_model(PROFILE_OUTLINE)profile_left_nostril = load_lms_model(PROFILE_LEFT_NOSTRIL)cheek = load_lms_model(CHEEK)mouth = load_lms_model(MOUTH)left_eye = load_lms_model(LEFT_EYE)simetry_plan = np.vstack([vertices[i] for i in zeros])"""profile_outline_copy = profile_outline.copy()for i in range(1,14):    print('i ', i)    pt = profile_outline_copy[-i][1:]    all_dists = []    for z in simetry_plan:        all_dists.append(np.sqrt((pt[0] - z[0])**2 + (pt[1] - z[1])**2 + (pt[2] - z[2])**2))    all_dists = np.vstack(all_dists)    index = np.argmin(all_dists, axis=0)    print('all dists index ', all_dists[index])    profile_outline_copy[-i] = np.hstack([zeros[index[0]], simetry_plan[index[0]]])profile_outline = profile_outline_copy"""#%%#for ear_file in EARS_FILES[1:2]:for i, file in enumerate(PROFILE_TRAIN):    print('INDEX: ', i)    #img_name = ear_file.split('/')[-1].split('_')[0]    img_name = file.split('/')[-1].split('.')[0]    #if os.path.exists(os.path.join(EX_FOLDER, img_name + '_base.png')):    yaw = pose_info[np.where((pose_info[:,0] == img_name + '.jpg'))[0]][0][-1]    img_info = data.values[int(img_name) -1]    pose = img_info[2]    lms = img_info[4]    #lms = update_landmarks(img_info)    img_path = os.path.join(os.getcwd(), img_info[0])    img = cv.imread(img_path)    img, lms = crop_image(img,img_path, lms, pose)    #print('img shape: ', np.shape(img))    left_eye_p = [left_eye[i] for i in [3, 4, 5, 0, 1, 2]]    ear = load_lms_model(EAR_FILE)    model_shape = np.concatenate((ear, cheek, mouth, profile_left_nostril, left_eye_p, profile_outline), axis = 0)[:,1:] #ears are not included because they are too variable    #model_shape = np.concatenate((ear, cheek, mouth, profile_left_nostril, left_eye_p, profile_outline_copy), axis = 0)[:,1:] #ears are not included because they are too variable    img_shape = np.vstack([lms[i] for i in [*range(0,10), *range(12,45)]])    img_shape_copy = img_shape.copy()    if img_shape[17][1] > img_shape[18][1]:        print('entrou')        img_shape[17] = img_shape_copy[18]        img_shape[18] = img_shape_copy[17]        img_shape[19] = img_shape_copy[16]        img_shape[14] = img_shape_copy[15]        img_shape[15] = img_shape_copy[14]        img_shape[16] = img_shape_copy[19]    # 1. GET TPS HALF OF FACE    # ==========================    rotation_matrix, translation_vector, K, angles, pitch_old = get_rigid_transformations(img, img_path, model_shape, img_shape)    print(pitch_old)    if abs(pitch_old) < 90:        # homogenous_pts - homogenous coordinates of the projected points        all_pts, homogenous_pts = project_pts(vertices, K, rotation_matrix, translation_vector)        indexes = get_indexes(vertices, model_shape)        img_copy = img.copy()        save_img_pts(all_pts, img_shape, img_copy, img_path, indexes, 'lms') # works ok!        #save_img_pts(all_pts, img_shape, img_copy, img_path, indexes, 'all_lms') # works ok!        back_projection = np.zeros(np.shape(vertices))        for i in range(len(vertices)):            back_projection[i] = get_back_projection(homogenous_pts[i,:], K)        ind_lms = [int(i) for i in indexes]        lms_back_projection = np.asarray([back_projection[i,:] for i in ind_lms])        lms_homo_pts = np.asarray([homogenous_pts[i,:] for i in ind_lms])        img_lms_bp = np.zeros((len(img_shape), 3))        for i in range(len(img_lms_bp)):                img_lms_bp[i][:] = get_back_projection(np.asarray([img_shape[i,0]*lms_homo_pts[i,-1],                                                                                                                            img_shape[i,1]*lms_homo_pts[i,-1],                                                                                                                            lms_homo_pts[i,-1]]), K) # assuming w is the depth        simetry_plan = np.vstack([back_projection[i] for i in zeros]) # the simetry plan will be the plan of unique points        #sim_lms_back_projection = get_simetric_points(simetry_plan, lms_back_projection)        #sim_img_lms_bp =  get_simetric_points(simetry_plan, img_lms_bp)        #final_img_lms_bp = np.concatenate((img_lms_bp, sim_img_lms_bp), axis = 0)        final_img_lms_bp,  excluded = get_simetric_points(simetry_plan, img_lms_bp)        final_lms_back_projection, _ = get_simetric_points(simetry_plan, lms_back_projection, excluded)        tps_back_projection = tps(final_lms_back_projection, final_img_lms_bp, back_projection)        pts_all, _ = project_pts(tps_back_projection, K)        img_copy = img.copy()        save_img_pts(pts_all, img_shape, img_copy, img_path, indexes, 'lms_proj') # works ok!        #save_2D_plot(img_shape, img_path, 'img_shape', c = 'r')        #save_2D_plot(model_shape, img_path, 'model_shape', c = 'r')        # GET FACES        # ==============        faces = []        for tri in triangles:            values = tri.split(' ')[:-1]            f = np.hstack([i.split('//')[0] for i in values])[1:]            f = f.astype(np.int)            f = [i - 1 for i in f]            faces.append(f)        mesh = trimesh.Trimesh(vertices = tps_back_projection, faces=faces, process=True)        centers = mesh.triangles_center        centers_projected, _ = project_pts(centers, K)        all_points, _ = project_pts(tps_back_projection, K)        sim_pts = {} #list of points to consider for color (center plus 3 vertices        for i, face in enumerate(faces):            simetric_face = []            #print('face: ', face)            for pt in face: #check if face has a simetric and if this is on the negative side                index = np.where(correspondence[:,0] == pt)[0]                if len(index) != 0:                    simetric_face.append(correspondence[index[0],1])                else:                    index = np.where(zeros == pt)[0]                    if len(index) != 0:                        simetric_face.append(pt)            if len(simetric_face) == 3:                sim_pts[i] = [centers_projected[i], all_points[face[0]], all_points[face[1]], all_points[face[2]]]                index_sim_face = np.where(faces == simetric_face)                for comb in [[0,2,1]]: #[0,1,2], [1,0,2], [1,2,0],[2,1,0],[2,0,1] (all were tested )                    array = np.asarray([simetric_face[comb[0]], simetric_face[comb[1]], simetric_face[comb[2]]])                    index_sim_face = np.where((faces == array).all(axis = 1))[0]                    if len(index_sim_face) != 0:                        #print(comb)                        break                #print(index_sim_face)                sim_pts[index_sim_face[0]] = [centers_projected[i], all_points[face[0]], all_points[face[1]], all_points[face[2]]]        sim_pts = list(sorted(sim_pts.items()))        colors = []        for pts in sim_pts:            pts = pts[1]            face_colors = []            for pt in pts:                if pt[0] > np.shape(img)[1] - 1:                    pt[0] = np.shape(img)[1] - 1                if pt[1] > np.shape(img)[0] - 1:                    pt[1] = np.shape(img)[0] - 1                color = img[int(pt[1])][int(pt[0])]                face_colors.append([color[-1], color[-2], color[-3]]) #BGR to RGB            face_colors = np.vstack(face_colors)            mean_color = list(np.mean(face_colors, axis = 0))            color = [*mean_color, 255]            colors.append(color)        mesh = trimesh.Trimesh(vertices = tps_back_projection, faces=faces)        for f in range(len(mesh.faces)):            mesh.visual.face_colors[f] = np.asarray(colors[f])#trimesh.visual.random_color()        scene = trimesh.scene.scene.Scene()        scene.add_geometry(mesh)        camera = scene.camera #RT_4x4 = scene.camera_transform        #print('K before: ', camera.K)        #print('resolution before: ', camera.resolution)        camera.K = K        #print('K after: ', camera.K)        #print('resolution after: ', camera.resolution)        RT = np.concatenate((np.eye(3), np.zeros((3, 1))), axis=-1)        RT_4x4 = np.concatenate([RT, np.array([0., 0., 0., 1.])[None, :]], 0)        RT_4x4 = np.linalg.inv(RT_4x4)        RT_4x4 = RT_4x4 @ np.diag([1, -1,-1, 1])        scene.camera_transform = RT_4x4        R_T = np.concatenate((rotation_matrix, translation_vector), axis=-1)        R_T = np.concatenate([R_T, np.array([0., 0., 0., 1.])[None, :]], 0)        png = scene.save_image(resolution =  None, background=[255,255,255,255],visible = True)        with open(os.path.join(EX_FOLDER, '%s_base_ppt.png' % (img_path.split('/')[-1].split('.')[0])), 'wb') as f:            f.write(png)            f.close()        vertices_abs = []        for v in tps_back_projection:            R_T_inv = np.linalg.inv(R_T)            v = list(v)            v.append(1)            v = np.dot(R_T_inv,np.asarray(v))            vertices_abs.append(v[:3])        mesh_abs = trimesh.Trimesh(vertices = vertices_abs, faces=faces)        #trimesh.exchange.export.export_mesh(mesh_abs,os.path.join(SHAPES, '%s.obj' % img_name))        save_object(os.path.join(SHAPES, '%s' % img_name), vertices_abs, triangles)        #save_object(img_name, vertices_abs, fac        with open(os.path.join(COLORS, 'colors_%s.pickle' % img_name), 'wb') as f:            # Pickle the 'data' dictionary using the highest protocol available.            pickle.dump(colors, f)        with open(os.path.join(SHAPES, '%s.pickle' % img_name), 'wb') as f:            # Pickle the 'data' dictionary using the highest protocol available.            pickle.dump(K, f)        #%%        """        fig = plt.figure()        ax = fig.add_subplot(111, projection='3d')        for i in range(len(profile_outline)):            ax.scatter(profile_outline[i, 1], profile_outline[i, 2], profile_outline[i, 3], c = 'r')            ax.text(profile_outline[i, 1], profile_outline[i, 2], profile_outline[i, 3],'%s' % (str(i)),size=20, zorder=1, color='k')        plt.show()        #%%        fig = plt.figure()        ax = fig.add_subplot(111, projection='3d')        ax.scatter(final_lms_back_projection[:, 0], final_lms_back_projection[:, 1], final_lms_back_projection[:, 2], c = 'b')        ax.scatter(final_img_lms_bp[:, 0],        final_img_lms_bp[:, 1],        final_img_lms_bp[:, 2], c = 'r')            #ax.text(profile_outline_copy[i, 1], profile_outline_copy[i, 2], profile_outline_copy[i, 3],'%s' % (str(i)),size=20, zorder=1, color='k')    #%%        fig = plt.figure()        ax = fig.add_subplot(111, projection='3d')        ax.scatter(final_lms_back_projection[:, 0], final_lms_back_projection[:, 1], final_lms_back_projection[:, 2], c = 'r')        ax.scatter(final_img_lms_bp[:, 0], final_img_lms_bp[:, 1], final_img_lms_bp[:, 2], c = 'b')        plt.show()        """